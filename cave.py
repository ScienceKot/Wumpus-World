# Importing all needed modules.
import random

# The cave class definition.
class Cave:
    def __init__(self):
        # Configuring the cave object.
        self.wumpus_alive = True
        self.agent_location = [0, 0]
        self.action_move = {
            "up" : {"x" : 0, "y" : -1},
            "left" : {"x" : -1, "y" : 0},
            "down" : {"x" : 0, "y" : 1},
            "right" : {"x" : 1, "y" : 0}
        }
        # Generating the environment.
        self.generate_env()

    def generate_env(self):
        # Generating the wumpus location.
        wumpus_y = random.randint(0, 3)
        wumpus_x = random.randint(0, 3)

        while True:
            # Generating the gold location.
            gold_y = random.randint(0, 3)
            gold_x = random.randint(0, 3)

            if [gold_y, gold_x] != [wumpus_y, wumpus_x]:
                break

        # Generating the pits locations.
        pit_yx = []
        for i in range(3):
            while True:
                y = random.randint(0, 3)
                x = random.randint(0, 3)

                if [y, x] != [wumpus_y, wumpus_x] and [y, x] != [gold_y, gold_x] and [y, x] not in pit_yx:
                    pit_yx.append([y, x])
                    break

        # Generating the empty cave.
        self.cave = [["" for i in range(4)] for j in range(4)]

        # Adding the wumpus, gold and pits.
        self.cave[wumpus_y][wumpus_x] = "W"
        self.cave[gold_y][gold_x] = "G"
        for yx in pit_yx:
            self.cave[yx[0]][yx[1]] = "P"

        # Adding the stench to neighbors of wumpus.
        stench_coordinates = self.get_neighbors(wumpus_y, wumpus_x)
        for stench in stench_coordinates:
            self.cave[stench[0]][stench[1]] += "s"

        # Adding the glitter to neighbors of gold.
        glitter_coordinates = self.get_neighbors(gold_y, gold_x)
        for glitter in glitter_coordinates:
            self.cave[glitter[0]][glitter[1]] += "g"

        # Adding the breeze to neighbors of pits.
        for yx in pit_yx:
            breeze_coordinates = self.get_neighbors(yx[0], yx[1])
            for breeze in breeze_coordinates:
                self.cave[breeze[0]][breeze[1]] += "b"

        # Adding the agent location.
        self.cave[
            self.agent_location[0]
        ][
            self.agent_location[1]
        ] += "A"

        # Printing out the cave.
        for i in range(len(self.cave)):
            for j in range(len(self.cave[i])):
                print(self.cave[i][j], end=" | ")
            print("\n")
            print("*"*20)

    def get_neighbors(self, y : int, x : int) -> list:
        '''
            This function returns the coordinates of the cell with the coordinates (x, y).
        :param y: int
            The row index of the cell.
        :param x: int
            The column index of the cell.
        :return: list
            The list of coordinates indexes.
        '''
        neighbors = [
            [y - 1, x], [y, x + 1], [y + 1, x], [y, x - 1]
        ]
        # Validation of neighbors:
        to_keep = []
        for i in range(len(neighbors)):
            if neighbors[i][0] >= 0 and neighbors[i][0] <= 3 and neighbors[i][1] >= 0 and neighbors[i][1] <= 3:
                to_keep.append(i)

        return [neighbors[i] for i in to_keep]

    def check_legal_location(self, y : int, x : int) -> bool:
        '''
            This function returns the existence of the cell.
        :param y: int
            The row index of the cell.
        :param x: int
            The column index of the cell.
        :return: list
            The list of coordinates indexes.
        '''
        if x >= 0 and x <= 3 and y >= 0 and y <= 3:
            return False
        else:
            return True

    def get_cell_data(self, y : int, x : int) -> dict:
        '''
            This function returns the senses of the cell.
        :param y: int
            The row index of the cell.
        :param x: int
            The column index of the cell.
        :return: dict
            The dictionary with the information generated by the cell.
        '''
        cell_string = self.cave[y][x]
        return {
            "stench" : True if "s" in cell_string else False,
            "breeze" : True if "b" in cell_string else False,
            "glitter" : True if "g" in cell_string else False,
        }

    def get_initial_date(self):
        '''
            THis function returns the initial information of the cave.
        :return: dict, list, bool, bool
        '''
        # Generating the initial dictionary of information.
        init = self.get_cell_data(0, 0)
        init["scream"] = False
        init["bump"] = False
        dead = False
        gold = False
        if "W" in self.cave[0][0] or "P" in self.cave[0][0]:
            dead = True
        if "G" in self.cave[0][0]:
            gold = True
        return init, self.agent_location, gold, dead

    def action(self, action : str) -> dict:
        '''
            This function applies the agents action to the cave environment.
        :param action: str
            The agent's action.
        :return: dict
        '''
        scream = False
        bump = False
        gold = False
        dead = False
        # Getting the senses of the cell.
        return_data = self.get_cell_data(
            self.agent_location[0],
            self.agent_location[1]
        )
        # Checking the action validity.
        if action in self.action_move:
            # Getting the new agent's location.
            new_loc_y = self.agent_location[0] + self.action_move[action]["y"]
            new_loc_x = self.agent_location[1] + self.action_move[action]["x"]
            # Checking for bump.
            bump = self.check_legal_location(new_loc_x, new_loc_y)
            if bump:
                pass
            else:
                # Getting the information for the cell.
                return_data = self.get_cell_data(
                    new_loc_y, new_loc_x
                )
                # Updating the agent's location.
                self.agent_location[0] = new_loc_y
                self.agent_location[1] = new_loc_x
            # Checking if the agent is in the same location as the wumpus.
            if "W" in self.cave[self.agent_location[0]][self.agent_location[1]] and self.wumpus_alive or "P" in self.cave[self.agent_location[0]][self.agent_location[1]]:
                # Setting the agent's death to True.
                dead = True
        elif action == "grab":
            # Checking if the Gold is in the same location as the agent.
            if "G" in self.cave[self.agent_location[0]][self.agent_location[1]]:
                gold = True
        elif "shoot" in action:
            # Shooting actions and checking if the wumpus dies.
            if action == "shoot-left":
                for i in range(self.agent_location[1]):
                    if "W" in self.cave[self.agent_location[1]][i]:
                        scream = True
                        self.wumpus_alive = False
                        break
            elif action == "shoot-right":
                for i in range(self.agent_location[1], len(self.cave)):
                    if "W" in self.cave[self.agent_location[1]][i]:
                        scream = True
                        self.wumpus_alive = False
                        break
            elif action == "shoot-up":
                for i in range(self.agent_location[0]):
                    if "W" in self.cave[i][self.agent_location[1]]:
                        scream = True
                        self.wumpus_alive = False
                        break
            elif action == "shoot-down":
                for i in range(self.agent_location[0], len(self.cave)):
                    if "W" in self.cave[i][self.agent_location[1]]:
                        scream = True
                        self.wumpus_alive = False
                        break
        # Adding the additional senses to the senses.
        return_data.update(
            {"bump" : bump, "scream" : scream}
        )
        print()
        self.update_cave()
        return return_data, self.agent_location, gold, dead

    def update_cave(self):
        '''
            This function prints nicely the cave.
        '''
        for i in range(len(self.cave)):
            for j in range(len(self.cave[i])):
                print(self.cave[i][j], end=" | ")
            print()
            print("*"*20)
